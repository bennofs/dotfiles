#!/usr/bin/env bash

# Script to run cabal inside a nix-shell.
# Author: Benno Fünfstück

# We pass command line arguments via xargs to allow spaces inside arguments
# To do that, we need to use newlines as separator ($* will expand to $1\n$2\n...)
IFS='
'

# The command that invokes cabal. We pass the path to GHC explicitly, because
# cabal caches this path in setup-config, but it changes everytime we change
# the nix expression. If we don't do this, sometimes not all dependencies will get
# picked up if we add to buildDepends without changing the cabal file.
command="xargs -a <(echo '$*$IFS--with-ghc=\$ghc/bin/ghc') -d '$IFS' cabal"

# Reset IFS
IFS=' '

# This expression loads default.nix, but also takes care of adding cabalInstall to
# buildInputs, because we want to use cabal inside our shell. It works if default.nix contains
# a function and also if it contains a function that still requires haskellPackages as an argument.
expr=$(cat <<'EOF'
with (import <nixpkgs> {});
let f = import ./.;
    deriv = if builtins.isFunction f
              then f { haskellPackages = import /etc/nixos/expr/hs-7.6 {}; }
              else f;
in lib.overrideDerivation deriv (old: {
     buildInputs = old.buildInputs ++ [ haskellPackages.cabalInstall haskellPackages.Cabal_1_20_0_1 ];
   })
EOF
)

# We want some environment variables to be preserved, even when using --pure. Because nix-shell doesn't currenlty
# support that natively, we just export them ourselves before invoking cabal.
#
# SSL vars: those are needed if we want to fetch SSL signed pages inside nix-shell
# NIX_REMOTE: allows to use nix inside nix-shell
preserveEnvs="CURL_CA_BUNDLE GIT_SSL_CAINFO OPENSSL_X509_CERT_FILE NIX_REMOTE"
setupEnv=""
for env in $preserveEnvs; do
  setupEnv="${setupEnv}export $env=${!env}; "
done

# Run nix-shell.
nix-shell -I nixpkgs=/home/channel --command "bash -c \"${setupEnv}$command\"" --pure --indirect --add-root .nix-7.6/dep -E "$expr"
