#!/usr/bin/env bash

################################################################################
# Script to start a nix-shell for a haskell project.
#
# Features:
#
# - Support SSL in shell (useful for testing network applications)
# - Support nix in shell (for example, allows you to run a nix-shell inside a nix-shell)
# - Preserve GTK theme in shell
# - Registers GC roots so that the dependencies are preserved on next GC run
#   (one GC root per GHC version)
# - Allows using a different shell
# - Filter a few useless directories from src (like .git, dist/, etc)
#
# Of course, the disadvantage is that these features make the shell a bit less pure.
#
# The script assumes that there is a default.nix file in the current directory
# that contains a function which takes one argument, haskellPackages and returns
# either a derivation or a set of derivations.
#
# All command-line arguments are passed to through to the invocation of nix-shell,
# so you can use the same arguments as to nix-shell.
#
# You can set the HS_SHELL_HOOK environment variable to run
# additional commands after the shell is started. Note that HS_SHELL_HOOK
# runs quite early in the shell setup process, so the environment might
# not be fully initialized yet. Use it only to set environment variables, etc.
#
# Author: Benno Fünfstück
################################################################################

# We want some environment variables to be preserved, even when using --pure. Because nix-shell doesn't currenlty
# support that natively, we just export them ourselves before invoking cabal.
# These environment variables are useful to test haskell code using the network or interfacing with nix
# inside a nix-shell.
#
# SSL vars: those are needed if we want to fetch SSL signed pages inside nix-shell
# NIX_REMOTE: allows to use nix inside nix-shell
# GTK_PATH, GTK2_RC_FILES: for theming inside nix-shell
preserveEnvs="CURL_CA_BUNDLE GIT_SSL_CAINFO OPENSSL_X509_CERT_FILE NIX_REMOTE GTK_PATH GTK2_RC_FILES"
setupEnv=""
for env in $preserveEnvs; do
  setupEnv="${setupEnv}export $env=${!env}; "
done

# Some projects provide a default.nix/shell.nix file that doesn't support our system. For this
# use case, we allow a .auto.nix file to override default.nix/shell.nix, but fallback to default.nix/shell.nix
# if no such file exists.
HS_SHELL_FILE_DEF="default.nix"
if [ -e shell.nix ]; then
  HS_SHELL_FILE_DEF="shell.nix"
fi
if [ -e .auto.nix ]; then
  HS_SHELL_FILE_DEF=".auto.nix"
fi
HS_SHELL_FILE=${HS_SHELL_FILE:-$HS_SHELL_FILE_DEF}

# Get the project name (assumed to be the name of the current directory)
# This is exposed via the NIX_SHELL_PROJECT environment variable inside the
# shell, so it can be used to create a custom prompt.
projectName=${PWD##*/}

# Packages that should be available inside the shell
extraPackages="haskellPackages.cabalInstall haskellPackages.cabalBounds less\
   git mercurial fish gitAndTools.hub utillinux bc man man_db nano openssh"

# This expression loads $HS_SHELL_FILE.
read -r -d '' expr <<EOF
let pkgs = (import <nixpkgs> {}); in
{ haskellPackages ? pkgs.haskellPackages }:

let
  inherit (import <nixpkgs> {}) lib;
  filterHaskellSrc = src:
    let
      ignoredDirs = [ ".git" ];
      ignoredFiles = [ "cabal.sandbox.config" ];
      predicate = path: type:
           !( type == "unknown"
           || type == "directory" && (builtins.elem (baseNameOf path) ignoredDirs
                                   || lib.hasPrefix ".nix" (baseNameOf path)
                                   || lib.hasPrefix "dist" (baseNameOf path)
                                   || lib.hasSuffix "cabal-sandbox" (baseNameOf path)
                                   )
           || type == "regular" && builtins.elem (baseNameOf path) ignoredFiles
           || type == "symlink"
           );
    in if builtins.typeOf src == "path"
      then builtins.filterSource predicate src
      else src;
  myHaskellPackages = haskellPackages.override {
    extension = _: super: {
      cabal = super.cabal.override (old: {
         extension = self: super: let nsuper = super // old.extension self super; in { src = filterHaskellSrc nsuper.src; };
      });
      buildLocalCabal = src: name: super.buildLocalCabal (filterHaskellSrc src) name;
    };
  };
  overrideEach = xs: f: if builtins.isFunction xs
    then overrideEach (xs { haskellPackages = myHaskellPackages; }) f
    else if pkgs.lib.isDerivation xs
      then pkgs.lib.overrideDerivation xs f
      else (pkgs.lib.mapAttrs (_: p: overrideEach p f) xs);
in overrideEach (import ./$HS_SHELL_FILE) (old: {
  buildInputs = old.buildInputs
    # The following packages must be compiled for the GHC version that we're using in the
    # shell, because they're either haskell libraries or use the GHC library.
    ++ [ haskellPackages.Cabal_1_20_0_2 haskellPackages.ghcCore ]

    # Add the user packages.
    ++ (with pkgs; [ $extraPackages ]);
  shellHook = ''
    $setupEnv
    export TERM=xterm # otherwise, ghc-pkg returns an error
    export EDITOR=nano # for git
    export NIX_SHELL_PROJECT="$projectName" # Can be used by shells to set the prompt for example
    eval "$HS_SHELL_HOOK"
  '';
  ghcPackages = old.ghc.GHCPackages;
})
EOF

# Run once to determine the GHC version that we're going to use. This is used to construct
# the directory name for the GC roots.
# Note: --command should come last, because later --command arguments override earlier ones
# and we want to override any --command options the user gave.
ghcVersion=$(nix-shell "$@" --pure --command "ghc --numeric-version" -E "$expr")
echo "Using GHC version: $ghcVersion" >&2

# Now run nix-shell for the user.
exec nix-shell --command "exec fish" "$@" --pure --indirect --add-root ".nix-$ghcVersion/dep" -E "$expr"
