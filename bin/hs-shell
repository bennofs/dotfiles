#!/usr/bin/env bash

# Script to start a nix-shell which also contains the cabal-install tool
# for a haskell project.
# The script assumes that there is a default.nix file in the current directory
# that takes one argument, haskellPackages.
# All options are passed through to nix-shell.
#
# You can set the HS_SHELL_HOOK environment variable to run
# additional commands after the shell is started.
#
# Author: Benno Fünfstück

# We want some environment variables to be preserved, even when using --pure. Because nix-shell doesn't currenlty
# support that natively, we just export them ourselves before invoking cabal.
# These environment variables are useful to test haskell code using the network or interfacing with nix
# inside a nix-shell.
#
# SSL vars: those are needed if we want to fetch SSL signed pages inside nix-shell
# NIX_REMOTE: allows to use nix inside nix-shell
# GTK_PATH, GTK2_RC_FILES: for theming inside nix-shell
preserveEnvs="CURL_CA_BUNDLE GIT_SSL_CAINFO OPENSSL_X509_CERT_FILE NIX_REMOTE GTK_PATH GTK2_RC_FILES"
setupEnv=""
for env in $preserveEnvs; do
  setupEnv="${setupEnv}export $env=${!env}; "
done

# Some projects provide a default.nix file that doesn't support our system. For this
# use case, we allow a .auto.nix file to override default.nix, but fallback to default.nix
# if no such file exists.
HS_SHELL_FILE_DEF="default.nix"
if [ -e shell.nix ]; then
  HS_SHELL_FILE_DEF="shell.nix"
fi
if [ -e .auto.nix ]; then
  HS_SHELL_FILE_DEF=".auto.nix"
fi
HS_SHELL_FILE=${HS_SHELL_FILE:-$HS_SHELL_FILE_DEF}

# Get the project name (assumed to be the name of the current directory)
# This is used for creating the prompt in the nix-shell
projectName=${PWD##*/}

# This expression loads $HS_SHELL_FILE, but also takes care of adding cabalInstall to
# buildInputs, because we want to use cabal inside our shell. It works if default.nix contains
# already a derviation, but also if it contains a function that still requires haskellPackages as
# an argument.

# Because only haskell libraries are GHC-version specific, we'll always use cabal install built
# by GHC 7.8.3, because that's what in the binary cache so we avoid rebuilding. We cannot do the same
# for the Cabal library though, unfortunaly, because it must be built for the GHC that's available
# in the sandbox (we cannot use a Cabal library built for GHC 7.8.3 if we only have GHC 7.6.3 in the sandbox).
read -r -d '' expr <<EOF
let pkgs = (import <nixpkgs> {}); in
{ haskellPackages ? pkgs.haskellPackages }:

let
  inherit (import <nixpkgs> {}) lib;
  filterHaskellSrc = src:
    let
      ignoredDirs = [ ".git" ];
      ignoredFiles = [ "cabal.sandbox.config" ];
      predicate = path: type:
           !( type == "unknown"
           || type == "directory" && (builtins.elem (baseNameOf path) ignoredDirs
                                   || lib.hasPrefix ".nix" (baseNameOf path)
                                   || lib.hasPrefix "dist" (baseNameOf path)
                                   || lib.hasSuffix "cabal-sandbox" (baseNameOf path)
                                   )
           || type == "regular" && builtins.elem (baseNameOf path) ignoredFiles
           || type == "symlink"
           );
    in if builtins.typeOf src == "path"
      then builtins.filterSource predicate src
      else src;
  myHaskellPackages = haskellPackages // {
    cabal = { mkDerivation = args: args // { src = filterHaskellSrc args.src; }; };
  };
in pkgs.lib.overrideDerivation (import ./$HS_SHELL_FILE { haskellPackages = myHaskellPackages; }) (old: {
  buildInputs = old.buildInputs ++ [ pkgs.haskellPackages.cabalInstall haskellPackages.Cabal_1_20_0_2 haskellPackages.ghcCore pkgs.haskellPackages.cabalBounds pkgs.less pkgs.git pkgs.mercurial pkgs.fish pkgs.gitAndTools.hub pkgs.utillinux pkgs.bc pkgs.man pkgs.man_db];
  shellHook = ''
    $setupEnv
    export TERM=xterm # otherwise, ghc-pkg returns an error
    export NIX_SHELL_PROJECT="$projectName" # Can be used by shells to set the prompt for example
    eval "$HS_SHELL_HOOK"
  '';
  ghcPackages = old.ghc.GHCPackages;
})
EOF

# Run once to determine the GHC version that we're going to use. This is used to construct
# the directory name for the GC roots.
# Note: --command should come last, because later --command arguments override earlier ones
# and we want to override any --command options the user gave.
ghcVersion=$(nix-shell "$@" -I nixpkgs=/home/channel --pure --command "ghc --numeric-version" $HS_SHELL_FILE)
echo "Using GHC version: $ghcVersion" >&2

# Now run nix-shell for the user.
exec nix-shell --command "exec fish" "$@" -I nixpkgs=/home/channel --pure --indirect --add-root ".nix-$ghcVersion/dep" -E "$expr"
