#!/usr/bin/env bash

################################################################################
# Script to start a nix-shell for a haskell project.
#
# Features:
#
# - Support SSL in shell (useful for testing network applications)
# - Support nix in shell (for example, allows you to run a nix-shell inside a nix-shell)
# - Preserve GTK theme in shell
# - Registers GC roots so that the dependencies are preserved on next GC run
#   (one GC root per GHC version)
# - Allows using a different shell
# - Filter a few useless directories from src (like .git, dist/, etc)
#
# Of course, the disadvantage is that these features make the shell a bit less pure.
#
# The script assumes that there is a default.nix file in the current directory
# that contains a function which takes one argument, haskellngPackages and returns
# either a derivation or a set of derivations.
#
# All command-line arguments are passed to through to the invocation of nix-shell,
# so you can use the same arguments as to nix-shell.
#
# You can set the HS_SHELL_HOOK environment variable to run
# additional commands after the shell is started. Note that HS_SHELL_HOOK
# runs quite early in the shell setup process, so the environment might
# not be fully initialized yet. Use it only to set environment variables, etc.
#
# Author: Benno Fünfstück
################################################################################

# We want some environment variables to be preserved, even when using --pure. Because nix-shell doesn't currenlty
# support that natively, we just export them ourselves before invoking cabal.
# These environment variables are useful to test haskell code using the network or interfacing with nix
# inside a nix-shell.
#
# SSL vars: those are needed if we want to fetch SSL signed pages inside nix-shell
# NIX_REMOTE: allows to use nix inside nix-shell
# GTK_PATH, GTK2_RC_FILES: for theming inside nix-shell
preserveEnvs="CURL_CA_BUNDLE GIT_SSL_CAINFO OPENSSL_X509_CERT_FILE NIX_REMOTE GTK_PATH GTK2_RC_FILES LANG"
setupEnv=""
for env in $preserveEnvs; do
  setupEnv="${setupEnv}export $env=${!env}; "
done

# Some projects provide a default.nix/shell.nix file that doesn't support our system. For this
# use case, we allow a .auto.nix file to override default.nix/shell.nix, but fallback to default.nix/shell.nix
# if no such file exists.
HS_SHELL_FILE_DEF="default.nix"
if [ -e shell.nix ]; then
  HS_SHELL_FILE_DEF="shell.nix"
fi
if [ -e .auto.nix ]; then
  HS_SHELL_FILE_DEF=".auto.nix"
fi
HS_SHELL_FILE=${HS_SHELL_FILE:-$HS_SHELL_FILE_DEF}

# Get the project name (assumed to be the name of the current directory)
# This is exposed via the NIX_SHELL_PROJECT environment variable inside the
# shell, so it can be used to create a custom prompt.
projectName=${PWD##*/}

# Packages that should be available inside the shell
extraPackages="less\
   git mercurial fish gitAndTools.hub utillinux bc man man_db nano openssh\
   haskellngPackages.cabal-bounds
   "
#   pkgs.haskellngPackages.codex pkgs.haskellngPackages.hasktags"

# This expression loads $HS_SHELL_FILE.
read -r -d '' expr <<EOF
let pkgs = (import <nixpkgs> {}); in
{ haskellngPackages ? pkgs.haskellngPackages }:

let
  inherit (import <nixpkgs> {}) lib;
  overrideEach = xs: f: if builtins.isFunction xs
    then overrideEach (xs { inherit haskellngPackages; }) f
    else if pkgs.lib.isDerivation xs
      then pkgs.lib.overrideDerivation (xs.override f.argumentOverrides) f.derivationOverrides
      else (pkgs.lib.mapAttrs (_: p: overrideEach p f) xs);
in overrideEach (import ./$HS_SHELL_FILE) {
  derivationOverrides = old: {
    buildInputs = old.buildInputs
      # The following packages must be compiled for the GHC version that we're using in the
      # shell, because they're either haskell libraries or use the GHC library.
      ++ [ haskellngPackages.ghc-core ]

      # Add the user packages.
      ++ (with pkgs; [ $extraPackages ]);
    shellHook = ''
      $setupEnv
      \${old.shellHook or ""}
      export TERM=xterm # otherwise, ghc-pkg returns an error
      export EDITOR=nano # for git
      export NIX_SHELL_PROJECT="$projectName" # Can be used by shells to set the prompt for example
      eval "$HS_SHELL_HOOK"
    '';
  };
  argumentOverrides = old: {
    mkDerivation = args:  old.mkDerivation (args // {
      buildDepends = [ haskellngPackages.foreign-store ] ++ args.buildDepends or [];
    });
  };
}
EOF

set -e
# Run once to determine the GHC version that we're going to use. This is used to construct
# the directory name for the GC roots.
# Note: --command should come last, because later --command arguments override earlier ones
# and we want to override any --command options the user gave.
ghcVersion=$(nix-shell "$@" --pure --command "ghc --numeric-version" -E "$expr")
echo "Using GHC version: $ghcVersion" >&2

# Now run nix-shell for the user.
exec nix-shell --command "exec env LOCALE_ARCHIVE=/run/current-system/sw/lib/locale/locale-archive fish" "$@" --pure --indirect --add-root ".nix-$ghcVersion/dep" -E "$expr"
